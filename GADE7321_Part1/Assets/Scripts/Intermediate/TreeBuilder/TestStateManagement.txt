using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Task.Nodes;
using UnityEngine.AI;

public class Tree : MonoBehaviour, IBTObserver
{
    private readonly List<Node> tree = new();
    private Node root = null;

    public Transform enemyAI;
    public NavMeshAgent enemyAgent;
    public Transform enemyFlag;
    public float nearDistance;
    public float attackDistance;
    public float strafeMultiplier;
    public float chaseDistance;
    public Vector2 randomMoveEvade = new Vector2(-20, 20);
    public Transform enemyBase;

    public Transform playerFlag;
    public Transform player;
    public float distanceOutBase;
    public Transform playerBase;
    public float nearPlayerDistance;

    private void Start()
    {
        BuildTree();
        SetupNodes();
    }

    private Node captureFlag;
    private Node returnToBase;
    
    private void SetupNodes()
    {
        captureFlag = new PickUpFlagNode(enemyAI, enemyAgent, enemyFlag, this);
        returnToBase = new ReturnToBaseNode(enemyBase, enemyAgent);
    }
    

    public Node BuildSequenceBranch(List<Node> children)
    {
        Node sequence = new Sequence(children);
        tree.Add(sequence);
        return sequence;
    }

    public Node BuildSelectorBranch(List<Node> children)
    {
        Node selector = new Selector(children);
        tree.Add(selector);
        return selector;
    }

    //Capture Flag
    private Node BuildCaptureFlagBranch()
    {
        Node captureFlag = BuildSelectorBranch(new List<Node>
        {
            new IsAICarryingFlagNode(enemyAI),
            new PickUpFlagNode(enemyAI, enemyAgent, enemyFlag, this),
        });

        return captureFlag;
    }
    
    private Node BuildAttackPlayerBranch()
    {
        Debug.Log("Attack Player");
        Node chasePlayer = BuildSequenceBranch(new List<Node>
        {
            new IsPlayerCarryingFlagNode(player),
            new CheckNearNode(nearDistance, enemyBase, enemyAI),
            new ChasePlayerNode(player, enemyAgent, attackDistance, this)
            
        });

        Node attack = BuildSequenceBranch(new List<Node>
        {
            new CheckNearNode(nearPlayerDistance, player, enemyAI),
            new AttackPlayerNode(player, enemyAI, attackDistance)
        });
        Node attackPlayer = BuildSequenceBranch(new List<Node>
        {
            chasePlayer,
            attack
        });

        return attackPlayer;
    }
    
    private Node BuildReturnHomeBranch()
    {
        
        Node returnHome = BuildSequenceBranch(new List<Node>
        {
            new IsAICarryingFlagNode(enemyAI),
            new ReturnToBaseNode(enemyBase, enemyAgent)
        });
        
        Node evadePlayer = BuildSequenceBranch(new List<Node>
        {
            new CheckNearNode(nearDistance, player, enemyAI),
            new IsPlayerCarryingFlagNode(player),
            new EvadePlayerNode(strafeMultiplier, player, enemyAgent, chaseDistance, randomMoveEvade)
        });
        
        Node returnToBase = BuildSequenceBranch(new List<Node>
        {
            evadePlayer,
            returnHome
        });

        return returnToBase;
    }
    
    private Node ResetOpponentFlag()
    {
        Node resetPlayerFlag = BuildSequenceBranch(new List<Node>
        {
            new PlayerDroppedFlagNode(distanceOutBase, playerBase, playerFlag, player),
            new PickUpFlagNode(enemyAI, enemyAgent, playerFlag, this)
            
        });

        return resetPlayerFlag;
    }

    private void BuildTree()
    {
        var captureFlag = BuildCaptureFlagBranch();
        var attackPlayer = BuildAttackPlayerBranch();
        var returnToBase = BuildReturnHomeBranch();
        var resetPlayerFlag = BuildReturnHomeBranch();
        //Node top = BuildSequenceBranch()

        root = new Selector(new List<Node>
        {
            captureFlag,
            attackPlayer,
            returnToBase,
            resetPlayerFlag
        });
    }

    private Node Test()
    {
        Node root = new Selector(new List<Node>
        {
            new PickUpFlagNode(enemyAI, enemyAgent, enemyFlag, this),
            new ReturnToBaseNode(enemyBase, enemyAgent)
        });

        return root;
    }
    

    private AIState currentState;

    private void Update()
    {
        EvaluateBehaviorTree();
    }

    private void EvaluateBehaviorTree()
    {
        switch (currentState)
        {
            case AIState.SearchingForFlag:
                if (captureFlag.Evaluate() == NodeState.Success)
                {
                    currentState = AIState.ReturningHome;
                }
                break;
            case AIState.ReturningHome:
                if (returnToBase.Evaluate() == NodeState.Success)
                {
                    // Consider what the next state should be
                    currentState = AIState.Idle; // Example next state
                }
                break;
            // Handle other states as needed
        }
    }

    public void OnNotify(string name)
    {
        Debug.Log($"Entering Node: {name}");
    }
}

public enum AIState
{
    SearchingForFlag,
    ReturningHome,
    Idle
}
